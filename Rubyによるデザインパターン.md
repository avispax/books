# 第 1 章 良いプログラムとパターン

- 変わるものを変わらないものから分離する
- インターフェイスに対してプログラムし,実装に対 して行わない
- 継承より集約
- 委譲,委譲,委譲
- 必要になるまで作るな

# 第 2 章 Ruby をはじめよう

いったん、この書籍で取り扱う Ruby についての説明。  
if 文とか。まぁ読まなくて OK。

# 第 3 章 Template Method

静的型付けの同名デザパタとの違いは、スーパークラスに abstract 等を書かずにオーバーライドすること。  
Ruby のサブクラスでは必要なメソッドのみを書けばよいので、よくある「あー、スーパーのこれ、使わないけど無いと怒られるから空っぽのメソッド書いとくか」ってのが不要。  
挙動とかはテストで担保すること。

# 第 4 章 Strategy

ご存知 Template Method の 委譲ベースの解決策。  
Java との違いは、Ruby では interface 定義って要らないんだよなってこと。

4.3 より
「この手の実装は Ruby のダックタイビング哲学に反するものです。
　 HTMLFormatter と PlainTextFormatter はどちらも outputreport メソッドを実装しているのですから,もうどちらも同じインターフェイスを共有していると,アヒル(ダック)は主張するでしょう。
　だから,本質的には何もしない基底クラスを作って押し込めるようなことはしなくていいのです。」
「一般に Rubist たちは Formatter 基底クラスをすっ飛ばすやり方を好みます。」

それに続けて、「Strategy 部分が簡単な関数で終わるなら、Lambda（関数オブジェクト） 渡しちゃえよ」ってことだった。

Python3 を使う中で、だいたいそういうイメージを考えてたから、改めて明示してくれた感じ。  
動的型付け言語の連携ってやっぱりそうなるよね。

自分は C++ できるので Lambda のイメージは関数ポインタ。

# 第 5 章 Observer

Observer の動的言語版。

キモとなるところは前章と同様で、次の 2 つ。

1. インターフェイスは用意せず直接 Class を書く
2. というかその Class は、いっそ Lambda（関数オブジェクト） として埋め込む

この章的にはそれが読み取れればよい。
章の殆どは、静的/動的言語に依らない Observer パターンの注意事項が書いてる。

# 第 6 章 Composite
